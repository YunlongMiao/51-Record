C51 COMPILER V9.60.0.0   FIN_DS1302                                                        03/14/2022 18:08:37 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE FIN_DS1302
OBJECT MODULE PLACED IN .\Objects\Fin_ds1302.obj
COMPILER INVOKED BY: D:\EN\C51\BIN\C51.EXE Fin_ds1302.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\Fin_ds1302.lst) TABS(2) OBJECT(.\Objects\Fin_ds1302.obj)

line level    source

   1          #include"Fin_ds1302.h"
   2          
   3          
   4          uchar add_write[]={0x8c,0x8a,0x88,0x86,0x84,0x82,0x80};//寄存器地址
   5          uchar add_read[]={0x8d,0x8b,0x89,0x87,0x85,0x83,0x81};
   6          uchar tim0[]={22,1,2,28,11,24,30,1,1};//年、星期、月、日、时、分、秒、12/24、PM/AM
   7          
   8          uchar tim_bcd[7];//保存读出的时间日期
   9          uchar tim[14];//保存分解开的十位、个位
  10          //uchar distim[14];
  11          void display_1302time();
  12          void write_1302_8(uchar dat);
  13          void write_1302_byte(uchar add,uchar dat);
  14          uchar read_1302_byte(uchar add);
  15          void ds1302_initial();
  16          void read_1302time();
  17          
  18          
  19          /****************写一个字节*************/
  20          /*************写地址，写数据（方式）**************/
  21          
  22          void write_1302_8(uchar dat)
  23          {
  24   1        uchar i,temp ;
  25   1        for(i=0; i<8; i++)
  26   1        {
  27   2          clk = 0;//时钟信号为低时，数据才能改变，同时为出现上升沿做准备
  28   2          temp  = dat&0x01;//取出最低位
  29   2          if(temp )
  30   2            io =1;//如果这一位为1，io拉高
  31   2          else 
  32   2            io=0;//如果这一位为0，io拉低
  33   2          clk = 1;//出现上升沿，1302读数据
  34   2          dat=dat>>1;//为送出下一位做准备
  35   2          
  36   2        }
  37   1      }
  38          
  39          /*****************写操作******************/
  40          /*************写地址，写数据（目的）**************/
  41          
  42          void write_1302_byte(uchar add,uchar dat)
  43          {
  44   1        ce =0;//不进行操作时拉低
  45   1        clk = 0;//时钟线开始前为低
  46   1        ce =1;//拉高启动一次写操作过程
  47   1        write_1302_8(add );//送地址字节
  48   1        write_1302_8(dat );//送数据字节
  49   1        ce =0;//一次写操作的结束
  50   1      }
  51          
  52          
  53          /*****************读操作*************/
  54          /*************写地址，读数据（sclk）**************/
C51 COMPILER V9.60.0.0   FIN_DS1302                                                        03/14/2022 18:08:37 PAGE 2   

  55          
  56          uchar read_1302_byte(uchar add)
  57          {
  58   1        uchar i,value;
  59   1        ce =0;
  60   1        clk =0;
  61   1        ce =1;//开始一次读操作
  62   1        write_1302_8(add );//送地址字节
  63   1        for(i=0; i<8; i++)
  64   1        {
  65   2          clk =0;//读数据时下降沿有效
  66   2          value =value >>1;//将上一次保存的数据移到次高位
  67   2          if(io)//若检测为1
  68   2            value =value|0x80;//将1放到最高位
  69   2          clk =1;//接受完一位后将时钟线拉高，为再次出现下降沿做准备
  70   2        
  71   2        }
  72   1        ce =0;//结束一次读操作过程
  73   1        return value ;//将读取的1字节数据传递出去
  74   1      }
  75          
  76          
  77          
  78          /***************初始化**************/
  79          /**********时间、日期的初始值设置**********/
  80          
  81          void ds1302_initial()
  82          {
  83   1        uchar i,temp;
  84   1        for(i=0; i<7; i++)//给寄存器赋初值之前，将日期、时间转换为BCD码
  85   1        {
  86   2          temp = tim0[i]/10;//取十位
  87   2          tim0[i]=temp*16+tim0[i]%10;//bcd 码
  88   2        }
  89   1      /****************************************************/  
  90   1      /************设置显示格式12/24，AM/PM*************************/
  91   1      /****************************************************/
  92   1          if(tim0[7]==1)
  93   1          {
  94   2            if(tim0[8]==1)
  95   2              tim0[4]|=0xa0;//12小时PM
  96   2            else
  97   2              tim0[4]|=0x80;//12小时AM
  98   2          }
  99   1          else
 100   1          {
 101   2            if(tim0[8]==1)
 102   2              tim0[4]|=0x20;//PM
 103   2            else
 104   2              tim0[4]|=0x00;//AM
 105   2          }
 106   1      /*****************************************************/
 107   1      /****************************************************/
 108   1      /****************************************************/
 109   1        write_1302_byte(0x8e,0x00);//给寄存器设置初始值之前，需要去掉写保护
 110   1        
 111   1        for(i=0; i<7; i++)//每次循环给一个寄存器赋初值
 112   1        {
 113   2          write_1302_byte(add_write[i],tim0[i]);
 114   2        }
 115   1        
 116   1        write_1302_byte(0x8e,0x80);//给寄存器设置初始值后，需要加上写保护
C51 COMPILER V9.60.0.0   FIN_DS1302                                                        03/14/2022 18:08:37 PAGE 3   

 117   1        
 118   1      
 119   1      }
 120          
 121          
 122          
 123          /***************读取时间并进行转换*************/
 124          
 125          void read_1302time()
 126          {
 127   1        uchar i;
 128   1        for(i=0; i<7; i++)//每次循环读一个寄存器内容，保存到tim_bcd[]数组中
 129   1        {
 130   2          tim_bcd[i]=read_1302_byte(add_read[i]);
 131   2      /****************************************************/
 132   2      /****************************************************/
 133   2      /****************************************************/    
 134   2          if(i==4)
 135   2          {
 136   3            tim_bcd[14] = tim_bcd[4];
 137   3            tim_bcd[4] = tim_bcd[4]& 0x1f;//11111
 138   3          }
 139   2      /****************************************************/
 140   2      /****************************************************/
 141   2      /****************************************************/    
 142   2        }
 143   1        
 144   1        for(i=0; i<7; i++)//将读出的日期、时间分解为十位和个位
 145   1        {
 146   2      //    distim[i*2]=(tim_bcd[i]/16)*10+tim_bcd[i]%16;
 147   2      //    distim[i*2+1]=0x20;
 148   2          tim[2*i]=tim_bcd[i]/16;
 149   2          tim[2*i+1]=tim_bcd[i]%16; 
 150   2        }
 151   1      }
 152          
 153          
 154          
 155          /***************显示日期和时间**************/
 156          
 157          void display_1302time()
 158          {
 159   1        
 160   1      //第一行
 161   1        write_com(0x80);
 162   1        write_data(0x30+tim[0]);//年
 163   1        write_data(0x30+tim[1]);
 164   1        write_data('-');
 165   1        write_data(0x30+tim[4]);//月
 166   1        write_data(0x30+tim[5]);
 167   1        write_data('-');
 168   1        write_data(0x30+tim[6]);//日
 169   1        write_data(0x30+tim[7]);
 170   1        write_data(' ');
 171   1      //  write_data(0x30+tim[2]);//周
 172   1        write_data(0x30+tim[3]);
 173   1        
 174   1      /*************************************/
 175   1      /*************************************/
 176   1      /*************************************/
 177   1        if(tim_bcd[14]&0x20==0x20)
 178   1          Putstring(0x85,"PM");
C51 COMPILER V9.60.0.0   FIN_DS1302                                                        03/14/2022 18:08:37 PAGE 4   

 179   1        else
 180   1          Putstring(0x85,"AM"); 
 181   1      /*************************************/
 182   1      /*************************************/
 183   1      /*************************************/
 184   1        
 185   1      //第二行
 186   1        write_com(0x90);
 187   1        write_data(0x30+tim[8]);
 188   1        write_data(0x30+tim[9]);
 189   1        write_data(':');
 190   1        write_data(0x30+tim[10]);
 191   1        write_data(0x30+tim[11]);
 192   1        write_data(':');
 193   1        write_data(0x30+tim[12]);
 194   1        write_data(0x30+tim[13]);
 195   1      
 196   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    574    ----
   CONSTANT SIZE    =      6    ----
   XDATA SIZE       =     44    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
