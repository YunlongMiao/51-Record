#include"Fin_ds1302.h"


uchar add_write[]={0x8c,0x8a,0x88,0x86,0x84,0x82,0x80};//寄存器地址
uchar add_read[]={0x8d,0x8b,0x89,0x87,0x85,0x83,0x81};
uchar tim0[]={22,1,2,28,11,24,30,1,1};//年、星期、月、日、时、分、秒、12/24、PM/AM

uchar tim_bcd[7];//保存读出的时间日期
uchar tim[14];//保存分解开的十位、个位
//uchar distim[14];
void display_1302time();
void write_1302_8(uchar dat);
void write_1302_byte(uchar add,uchar dat);
uchar read_1302_byte(uchar add);
void ds1302_initial();
void read_1302time();


/****************写一个字节*************/
/*************写地址，写数据（方式）**************/

void write_1302_8(uchar dat)
{
	uchar i,temp ;
	for(i=0; i<8; i++)
	{
		clk = 0;//时钟信号为低时，数据才能改变，同时为出现上升沿做准备
		temp  = dat&0x01;//取出最低位
		if(temp )
			io =1;//如果这一位为1，io拉高
		else 
			io=0;//如果这一位为0，io拉低
		clk = 1;//出现上升沿，1302读数据
		dat=dat>>1;//为送出下一位做准备
		
	}
}

/*****************写操作******************/
/*************写地址，写数据（目的）**************/

void write_1302_byte(uchar add,uchar dat)
{
	ce =0;//不进行操作时拉低
	clk = 0;//时钟线开始前为低
	ce =1;//拉高启动一次写操作过程
	write_1302_8(add );//送地址字节
	write_1302_8(dat );//送数据字节
	ce =0;//一次写操作的结束
}


/*****************读操作*************/
/*************写地址，读数据（sclk）**************/

uchar read_1302_byte(uchar add)
{
	uchar i,value;
	ce =0;
	clk =0;
	ce =1;//开始一次读操作
	write_1302_8(add );//送地址字节
	for(i=0; i<8; i++)
	{
		clk =0;//读数据时下降沿有效
		value =value >>1;//将上一次保存的数据移到次高位
		if(io)//若检测为1
			value =value|0x80;//将1放到最高位
		clk =1;//接受完一位后将时钟线拉高，为再次出现下降沿做准备
	
	}
	ce =0;//结束一次读操作过程
	return value ;//将读取的1字节数据传递出去
}



/***************初始化**************/
/**********时间、日期的初始值设置**********/

void ds1302_initial()
{
	uchar i,temp;
	for(i=0; i<7; i++)//给寄存器赋初值之前，将日期、时间转换为BCD码
	{
		temp = tim0[i]/10;//取十位
		tim0[i]=temp*16+tim0[i]%10;//bcd 码
	}
/****************************************************/	
/************设置显示格式12/24，AM/PM*************************/
/****************************************************/
		if(tim0[7]==1)
		{
			if(tim0[8]==1)
				tim0[4]|=0xa0;//12小时PM
			else
				tim0[4]|=0x80;//12小时AM
		}
		else
		{
			if(tim0[8]==1)
				tim0[4]|=0x20;//PM
			else
				tim0[4]|=0x00;//AM
		}
/*****************************************************/
/****************************************************/
/****************************************************/
	write_1302_byte(0x8e,0x00);//给寄存器设置初始值之前，需要去掉写保护
	
	for(i=0; i<7; i++)//每次循环给一个寄存器赋初值
	{
		write_1302_byte(add_write[i],tim0[i]);
	}
	
	write_1302_byte(0x8e,0x80);//给寄存器设置初始值后，需要加上写保护
	

}



/***************读取时间并进行转换*************/

void read_1302time()
{
	uchar i;
	for(i=0; i<7; i++)//每次循环读一个寄存器内容，保存到tim_bcd[]数组中
	{
		tim_bcd[i]=read_1302_byte(add_read[i]);
/****************************************************/
/****************************************************/
/****************************************************/		
		if(i==4)
		{
			tim_bcd[14] = tim_bcd[4];
			tim_bcd[4] = tim_bcd[4]& 0x1f;//11111
		}
/****************************************************/
/****************************************************/
/****************************************************/		
	}
	
	for(i=0; i<7; i++)//将读出的日期、时间分解为十位和个位
	{
//		distim[i*2]=(tim_bcd[i]/16)*10+tim_bcd[i]%16;
//		distim[i*2+1]=0x20;
		tim[2*i]=tim_bcd[i]/16;
		tim[2*i+1]=tim_bcd[i]%16;	
	}
}



/***************显示日期和时间**************/

void display_1302time()
{
	
//第一行
	write_com(0x80);
	write_data(0x30+tim[0]);//年
	write_data(0x30+tim[1]);
	write_data('-');
	write_data(0x30+tim[4]);//月
	write_data(0x30+tim[5]);
	write_data('-');
	write_data(0x30+tim[6]);//日
	write_data(0x30+tim[7]);
	write_data(' ');
//	write_data(0x30+tim[2]);//周
	write_data(0x30+tim[3]);
	
/*************************************/
/*************************************/
/*************************************/
	if(tim_bcd[14]&0x20==0x20)
		Putstring(0x85,"PM");
	else
		Putstring(0x85,"AM");	
/*************************************/
/*************************************/
/*************************************/
	
//第二行
	write_com(0x90);
	write_data(0x30+tim[8]);
	write_data(0x30+tim[9]);
	write_data(':');
	write_data(0x30+tim[10]);
	write_data(0x30+tim[11]);
	write_data(':');
	write_data(0x30+tim[12]);
	write_data(0x30+tim[13]);

}